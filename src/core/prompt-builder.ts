/**
 * Prompt Builder
 *
 * Assembles prompts from the library into a CLAUDE.md file.
 * This is the core engine that generates the system prompt.
 *
 * Assembly order:
 * 1. Header (vibe-code attribution)
 * 2. Base security prompt (always included)
 * 3. Mode-specific prompt (learning/guided/expert)
 * 4. Standards (typescript, api)
 * 5. Security checklist
 * 6. Custom prompts (if any)
 *
 * Security notes:
 * - No user input directly in prompts
 * - Custom prompts are file paths, not raw content injection
 * - Output path validated to project root
 */

import { writeFile, readFile } from "fs/promises";
import { join, resolve } from "path";
import type { MergedConfig, Mode, ChecklistType, StandardType, Result } from "../types/index.js";

// Import prompt modules
import { getBasePrompt } from "../prompts/base.js";
import { getLearningModePrompt } from "../prompts/modes/learning.js";
import { getGuidedModePrompt } from "../prompts/modes/guided.js";
import { getExpertModePrompt } from "../prompts/modes/expert.js";
import { getSecurityChecklist } from "../prompts/checklists/security.js";
import { getTypeScriptStandardsPrompt } from "../prompts/standards/typescript.js";
import { getApiStandardsPrompt } from "../prompts/standards/api.js";

/**
 * CLAUDE.md file name
 */
const CLAUDE_MD = "CLAUDE.md";

/**
 * Generate the header section
 */
function buildHeader(config: MergedConfig): string {
  const projectLine =
    config.projectName !== undefined && config.projectName !== ""
      ? `Project: ${config.projectName}\n`
      : "";

  return `<!--
  Generated by vibe-code
  Mode: ${config.mode}
  ${projectLine}
  Do not edit manually - regenerate with 'vibe init' or 'vibe mode'
-->

`;
}

/**
 * Get the mode-specific prompt
 */
function getModePrompt(mode: Mode): string {
  switch (mode) {
    case "learning":
      return getLearningModePrompt();
    case "guided":
      return getGuidedModePrompt();
    case "expert":
      return getExpertModePrompt();
  }
}

/**
 * Get a standard prompt by type
 */
function getStandardPrompt(standard: StandardType): string {
  switch (standard) {
    case "typescript":
      return getTypeScriptStandardsPrompt();
    case "api":
      return getApiStandardsPrompt();
  }
}

/**
 * Build the standards section
 */
function buildStandards(standards: StandardType[]): string {
  if (standards.length === 0) {
    return "";
  }

  const sections = standards.map((standard) => getStandardPrompt(standard));
  return sections.join("\n\n");
}

/**
 * Build the checklist section
 */
function buildChecklist(checklistType: ChecklistType): string {
  if (checklistType === "none") {
    return "";
  }

  return getSecurityChecklist(checklistType);
}

/**
 * Load custom prompts from files
 * Custom prompts are markdown files in the project
 */
async function loadCustomPrompts(
  projectRoot: string,
  promptPaths: string[]
): Promise<Result<string>> {
  if (promptPaths.length === 0) {
    return { success: true, data: "" };
  }

  const sections: string[] = [];

  for (const promptPath of promptPaths) {
    // Resolve path relative to project root
    const fullPath = resolve(projectRoot, promptPath);

    // Security: Ensure path is within project root
    const resolvedRoot = resolve(projectRoot);
    if (!fullPath.startsWith(resolvedRoot)) {
      return {
        success: false,
        error: new Error(`Custom prompt path escapes project root: ${promptPath}`),
      };
    }

    try {
      const content = await readFile(fullPath, "utf-8");
      sections.push(`<!-- Custom: ${promptPath} -->\n${content}`);
    } catch {
      return {
        success: false,
        error: new Error(`Failed to load custom prompt: ${promptPath}`),
      };
    }
  }

  return {
    success: true,
    data: sections.join("\n\n"),
  };
}

/**
 * Assemble all prompts into a single CLAUDE.md content string
 */
export async function assemblePrompts(
  config: MergedConfig,
  projectRoot: string
): Promise<Result<string>> {
  const sections: string[] = [];

  // 1. Header
  sections.push(buildHeader(config));

  // 2. Base security prompt (always included)
  sections.push(getBasePrompt());

  // 3. Mode-specific prompt
  sections.push(getModePrompt(config.mode));

  // 4. Standards (if any)
  const standards = buildStandards(config.includeStandards);
  if (standards) {
    sections.push(standards);
  }

  // 5. Security checklist (if not "none")
  const checklist = buildChecklist(config.includeSecurityChecklist);
  if (checklist) {
    sections.push(checklist);
  }

  // 6. Custom prompts (if any)
  if (config.customPrompts.length > 0) {
    const customResult = await loadCustomPrompts(projectRoot, config.customPrompts);
    if (!customResult.success) {
      return customResult;
    }
    if (customResult.data) {
      sections.push(customResult.data);
    }
  }

  // Join with double newlines for readability
  const content = sections.join("\n\n");

  return { success: true, data: content };
}

/**
 * Get the CLAUDE.md file path for a project
 */
export function getClaudeMdPath(projectRoot: string): string {
  return join(resolve(projectRoot), CLAUDE_MD);
}

/**
 * Write CLAUDE.md to the project root
 */
export async function writeClaudeMd(
  projectRoot: string,
  content: string
): Promise<Result<void>> {
  try {
    const path = getClaudeMdPath(projectRoot);
    await writeFile(path, content, "utf-8");
    return { success: true, data: undefined };
  } catch (error) {
    const message =
      error instanceof Error ? error.message : "Failed to write CLAUDE.md";
    return { success: false, error: new Error(message) };
  }
}

/**
 * Build and write CLAUDE.md for a project
 * This is the main entry point for generating the prompt file
 */
export async function buildClaudeMd(
  config: MergedConfig,
  projectRoot: string
): Promise<Result<string>> {
  // Assemble prompts
  const assembleResult = await assemblePrompts(config, projectRoot);
  if (!assembleResult.success) {
    return assembleResult;
  }

  // Write to file
  const writeResult = await writeClaudeMd(projectRoot, assembleResult.data);
  if (!writeResult.success) {
    return { success: false, error: writeResult.error };
  }

  // Return the path for confirmation
  const path = getClaudeMdPath(projectRoot);
  return { success: true, data: path };
}

/**
 * Preview what CLAUDE.md would contain without writing
 * Useful for dry-run or display purposes
 */
export async function previewClaudeMd(
  config: MergedConfig,
  projectRoot: string
): Promise<Result<string>> {
  return assemblePrompts(config, projectRoot);
}

/**
 * Get info about what will be included in CLAUDE.md
 */
export function getPromptManifest(config: MergedConfig): {
  mode: Mode;
  sections: string[];
  estimatedLines: number;
} {
  const sections: string[] = ["Header", "Base Security Prompt", `Mode: ${config.mode}`];

  if (config.includeStandards.length > 0) {
    sections.push(`Standards: ${config.includeStandards.join(", ")}`);
  }

  if (config.includeSecurityChecklist !== "none") {
    sections.push(`Checklist: ${config.includeSecurityChecklist}`);
  }

  if (config.customPrompts.length > 0) {
    sections.push(`Custom Prompts: ${String(config.customPrompts.length)} files`);
  }

  // Rough estimate of lines (for display purposes)
  let estimatedLines = 50; // Header + base
  estimatedLines += config.mode === "learning" ? 120 : config.mode === "guided" ? 150 : 100;
  estimatedLines += config.includeStandards.length * 150;
  estimatedLines += config.includeSecurityChecklist !== "none" ? 80 : 0;

  return {
    mode: config.mode,
    sections,
    estimatedLines,
  };
}
